@mixin grid-context {
  $-gridkit-context: () !global;
  @content;
}

// In order to be compatible across grid and flex we need to translate repeats
// into explicit
@function repeat($count, $val) {
  $str: $val;
  @for $i from 2 through $count {
    $str: $str + " " + $val;
  }
  @return $str;
}

// Started from https://stackoverflow.com/questions/32376461/how-to-split-a-string-into-two-lists-of-numbers-in-sass
// modified to allow multiple contiguous separators
@function str-split($string, $separator) {
    // empty array/list
    $split-arr: ();
    // first index of separator in string
    $index : str-index($string, $separator);
    // loop through string
    @while $index != null {
        // get the substring from the first character to the separator
        $item: str-slice($string, 1, $index - 1);

        @if (str-length($item) > 0) {
          // push item to array
          $split-arr: append($split-arr, $item);
        }
        // remove item and separator from string
        $string: str-slice($string, $index + 1);
        // find new index of separator
        $index : str-index($string, $separator);
    }
    // add the remaining string to list (the last item)
    $split-arr: append($split-arr, $string);

    @return $split-arr;
}

@function is-fr($value) {
  @return (str-index(inspect($value), 'fr') != null);
}

// $direction should be either columns or rows
@function translate-fr($value, $direction) {
  @if (is-fr($value)) {
    $vals: str-split(map-get($-gridkit-context, $direction), ' ');
    $numFrs: 0;
    $calcStr: '(0';
    @for $i from 1 through length($vals) {
      $val: nth($vals, $i);
      @if (is-fr($val)) {
        $numFrs: $numFrs + 1;
      } @else {
        $calcStr: '#{$calcStr} + #{$val}';
      }
    }
    $calcStr: '#{$calcStr})';
    $fr-value: '((100% - #{$calcStr}) / #{$numFrs})';
    $val: nth(str-split($value, 'fr'), 1);
    @return '(#{$val} * #{$fr-value})';
  } @else {
    @return $value;
  }
}

@function get-areas-matrix {
  $areas: map-get($-gridkit-context, areas);
  $matrix: ();
  @for $i from 1 through length($areas) {
    $matrix: append($matrix, str-split(nth($areas, $i), " "));
  }
  @return $matrix;
}

@function update-area-map($map, $area, $x, $y) {
  $obj: (min-x: 9999999, min-y: 9999999, max-x: 0, max-y: 0);
  @if map-has-key($map, $area) {
    $obj: map-get($map, $area);
  }

  $min-x: min(map-get($obj, min-x), $x);
  $min-y: min(map-get($obj, min-y), $y);
  $max-x: max(map-get($obj, max-x), $x);
  $max-y: max(map-get($obj, max-y), $y);
  @return map-merge($map, ($area: (min-x: $min-x, min-y: $min-y, max-x: $max-x, max-y: $max-y)))
}

@function get-areas-map {
  $matrix: get-areas-matrix();
  $map: ();
  @for $y from 1 through length($matrix) {
    $row: nth($matrix, $y);
    @for $x from 1 through length($row) {
      $area: nth($row, $x);
      $map: update-area-map($map, $area, $x, $y);
    }
  }
  @return $map;
}

@function annotate-areas-map($map) {
  $columns: map-get($-gridkit-context, columns);
  $rows:    map-get($-gridkit-context, rows);
  @if(type-of($columns) == 'string') {
    $columns: str-split($columns, ' ');
  }
  @if(type-of($rows) == 'string') {
    $rows: str-split($rows, ' ');
  }

  $areas: map-keys($map);
  @for $i from 1 through length($areas) {
    $key: nth($areas, $i);
    $area: map-get($map, $key);
    $widths: ();
    $heights: ();

    //TODO: Deal with auto (non explicit);
    @for $col from map-get($area, min-x) through map-get($area, max-x) {
      $widths: append($widths, translate-fr(nth($columns, $col), columns));
    }
    @for $row from map-get($area, min-y) through map-get($area, max-y) {
      $heights: append($heights, translate-fr(nth($rows, $row), rows));
    }
    $area: map-merge($area, (widths: $widths, heights: $heights));
    $map: map-merge($map, ($key: $area));
  }
  @return $map;
}

@function get-annotated-areas-map() {
  $map: get-areas-map();
  @return annotate-areas-map($map);
}

@function cached-areas-map {
  @if map-has-key($-gridkit-context, areas-map) {
    @return map-get($-gridkit-context, areas-map);
  } @else {
    $-gridkit-context: map-merge($-gridkit-context, (areas-map: get-annotated-areas-map())) !global;
    @return map-get($-gridkit-context, areas-map);
  }
}

@function width-string($key) {
  @return -calc-str($key, widths);
}

@function height-string($key) {
  @return -calc-str($key, heights);
}

// $type should be widths or heights
@function -calc-str($key, $type) {
  $map: cached-areas-map();
  $area: map-get($map, $key);
  $values: map-get($area, $type);

  $str: 'calc(' + nth($values, 1);
  @if (length($values) > 1) {
    @for $i from 2 through length($values) {
      $str: '#{$str} + #{nth($values, $i)}'
    }
  }
  $str: $str + ')';
  @return $str;
}
